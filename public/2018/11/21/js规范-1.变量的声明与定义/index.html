<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Jared Young,nocis@tju.edu.cn"><title>js规范-1.变量的声明与定义 · Jared Young's Workshop</title><meta name="description" content="1 变量提升JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 
JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。
注: JavaScript 只有声明的变量会提升，初始化的不会。
1234var x = 5; // 初始化 xelem = docume"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Jared Young's Workshop</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"></ul><div class="footer"><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="baidu.com">About</a></li><li><a href="/archives">Archive</a></li><li><a href="baidu.com">Links</a></li><li><a href="/vis/temp.html">vis</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/16632027?s=460&amp;v=4"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>js规范-1.变量的声明与定义</a></h3></div><div class="post-content"><h4 id="1-变量提升"><a href="#1-变量提升" class="headerlink" title="1 变量提升"></a>1 变量提升</h4><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 </p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p><strong>注: JavaScript 只有声明的变量会提升，初始化的不会。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素 </span></span><br><span class="line">elem.innerHTML = x + <span class="string">" "</span> + y;           <span class="comment">// 显示 x 和 y</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"><span class="keyword">var</span> y;     <span class="comment">// 声明 y</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x + <span class="string">" "</span> + y;           <span class="comment">// 显示 x 和 y</span></span><br><span class="line"></span><br><span class="line">y = <span class="number">7</span>;    <span class="comment">// 设置 y 为 7</span></span><br></pre></td></tr></table></figure>
<p>故y值在调用时是未定义变量，undefined</p>
<p><strong>js中的严格模式strict mode不允许使用未声明变量，故建议在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤。</strong></p>
<p><strong>注：js中虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"><span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数、变量声明提升后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName();    <span class="comment">// 最终输出：2</span></span><br></pre></td></tr></table></figure>
<h4 id="2-js的解析机制"><a href="#2-js的解析机制" class="headerlink" title="2 js的解析机制"></a>2 js的解析机制</h4><p>遇到 script 标签的话 js 就进行<strong>预解析</strong>，将变量 var 和 function 声明提升，但不会执行 function，然后就进入上下文执行，上下文执行还是执行预解析同样操作，直到没有 var  和 function，就开始执行上下文。</p>
<h4 id="3-变量声明的方式及作用域"><a href="#3-变量声明的方式及作用域" class="headerlink" title="3 变量声明的方式及作用域"></a>3 变量声明的方式及作用域</h4><ol>
<li><p><strong>使用var（最常见）</strong> </p>
<p>　 var声明的变量可以是全局的（函数外面），也可以是局部的（函数内部）**</p>
</li>
</ol>
<p>​     <strong>注：在函数外面使用var声明一个变量后，再在函数内部使用var再次声明一次并改变其值，函数外面的该变量的值不会发生改变。 </strong></p>
<ol start="2">
<li><strong>使用let</strong></li>
</ol>
<p>​       let声明的变量在{}中使用，变量的作用域限制在块级域中（<strong>并不等价于 </strong>函数内的局部变量）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = buttons.children <span class="comment">//用var声明了一个全局变量children，储存buttons的所有子元素 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;children.length; i++)</span><br><span class="line">&#123; </span><br><span class="line">    children[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//执行点击事件的时候输出对应的第几个按钮 </span></span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无论你点击什么，输出结果都是4，因为内存里只存了一个i，这个i的最终运算结果是4</span></span><br></pre></td></tr></table></figure>
<p>但是如果你把<code>var i = 0</code>改成<code>let i = 0</code>就可以得到你想要的结果。因为如果你使用let的话，每次循环都是引用的都是不同的i（引用了i变量的不同实例）。</p>
<h4 id="4-一条语句多个变量"><a href="#4-一条语句多个变量" class="headerlink" title="4 一条语句多个变量"></a>4 一条语句多个变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"Gates"</span>, age=<span class="number">56</span>, job=<span class="string">"CEO"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"Gates"</span>,</span><br><span class="line">    age=<span class="number">56</span>,</span><br><span class="line">    job=<span class="string">"CEO"</span>;</span><br></pre></td></tr></table></figure>
<p>以上两种都可行</p>
<h4 id="5-语句的解析顺序"><a href="#5-语句的解析顺序" class="headerlink" title="5. 语句的解析顺序"></a>5. 语句的解析顺序</h4><p>第一种：var a = b = 3;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b = <span class="number">3</span>; <span class="comment">//实际是以下声明的简写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">//变量提升 </span></span><br><span class="line">b = <span class="number">3</span>; <span class="comment">//文法树</span></span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不等于如下声明</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a = b;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">----------------</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">3</span>;</span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a defined? "</span> + (<span class="keyword">typeof</span> a !== <span class="string">'undefined'</span>)); <span class="comment">//false, var a 在立即执行函数的内部，成为了局部变量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b defined? "</span> + (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>)); <span class="comment">//true, b=3 使得b成为了全局变量（js 弱类型语言，变量不声明直接使用，则默认作为全局变量）</span></span><br></pre></td></tr></table></figure>
<p>第二种：var a,b = 3;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b = <span class="number">3</span> <span class="comment">//实际是以下声明的简写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">//a = undefined 局部变量</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>; <span class="comment">//b = 3 局部变量， 注意，初始化不会变量提升</span></span><br></pre></td></tr></table></figure>
<h4 id="6-逗号运算符"><a href="#6-逗号运算符" class="headerlink" title="6. 逗号运算符"></a>6. 逗号运算符</h4><p><strong>逗号运算符</strong>：逗号之前所有的运算表达式都会执行,但整个语句的值是最后一个表达式的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (b=<span class="number">2</span>, c=<span class="number">3</span>, <span class="number">4</span>==<span class="number">4</span>); <span class="comment">// a=true，b=2，c=3</span></span><br></pre></td></tr></table></figure>
<h4 id="7-js-函数参数"><a href="#7-js-函数参数" class="headerlink" title="7. js 函数参数"></a>7. js 函数参数</h4><p>javascript中的函数定义<strong>并未指定</strong>函数形参的类型，函数调用也<strong>未</strong>对传入的实参值做<strong>任何类型检查</strong>。实际上，javascript函数调用甚至<strong>不检查</strong>传入形参的个数</p>
<h5 id="7-1-同名形参"><a href="#7-1-同名形参" class="headerlink" title="7.1. 同名形参"></a>7.1. 同名形参</h5><p>在非严格模式下，函数中可以出现同名形参，且只能访问<strong>最后出现</strong>的该名称的形参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,x,x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>而在严格模式下，出现同名形参会抛出语法错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,x,x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//SyntaxError: Duplicate parameter name not allowed in `</span></span><br></pre></td></tr></table></figure>
<h5 id="7-2-参数个数"><a href="#7-2-参数个数" class="headerlink" title="7.2. 参数个数"></a>7.2. 参数个数</h5><ol>
<li>当实参比函数声明指定的形参个数要少，剩下的形参都将设置为undefined值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);<span class="comment">//1 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>当实参比形参个数要多时，剩下的实参没有办法直接获得，需要使用即将提到的<strong>arguments对象</strong></p>
<p>javascript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。arguments对象并不是Array的实例，它是一个类数组对象，可以使用方括号语法访问它的每一个元素</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//2，只传入x，y，return x+1;</span></span><br><span class="line"><span class="built_in">console</span>.log(add.length);  <span class="comment">//2</span></span><br><span class="line"><span class="comment">//arguments对象的length属性显示实参的个数，函数的length属性显示形参的个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">// 3, 只传入了3</span></span><br><span class="line">alert((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// 4,（3，4）的结果是4，传入alert的参数值也是4</span></span><br></pre></td></tr></table></figure>
<p><strong>注:   形参只是提供便利，但不是必需的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p><strong>注：在普通模式下，arguments对象的值和形参的值是同步的，当且仅当形参与实参的个数相同时。但！！在严格模式下，arguments对象的值和形参的值是！！独立的！！</strong></p>
<p>虽然命名参数和对应arguments对象的值相同，但并不是相同的命名空间，它们的命名空间是独立的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1,<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//1 1</span></span><br><span class="line"><span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1,<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//1 2</span></span><br><span class="line">num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1,<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//10 2</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注：当形参并没有对应的实参时，arguments对象的值与形参的值并不对应</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num1,<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//undefined,undefined</span></span><br><span class="line">num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1,<span class="built_in">arguments</span>[<span class="number">0</span>]);<span class="comment">//10,5</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<h5 id="7-3-对象参数"><a href="#7-3-对象参数" class="headerlink" title="7.3. 对象参数"></a>7.3. 对象参数</h5><p>可以通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">arraycopy(args.from,args.form_start || <span class="number">0</span>,args.to,args.to_start || <span class="number">0</span>, args.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],b =[];</span><br><span class="line">easycopy(&#123;<span class="attr">form</span>:a,<span class="attr">to</span>:b,<span class="attr">length</span>:<span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="8-函数的内部属性"><a href="#8-函数的内部属性" class="headerlink" title="8. 函数的内部属性"></a>8. 函数的内部属性</h4><p><strong>一、callee</strong></p>
<p>arguments的作用是保存传入函数中的所有参数，而且这个arguments有一个名叫callee的属性，这个属性是一个指针，指向拥有arguments对象的函数。</p>
<p>举个递归算法—阶乘函数的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*factorial(num<span class="number">-1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，在函数有名字，而且名字以后也不会变的情况下，这样定义没有啥问题。不过，这样这个函数的执行与函数名紧紧耦合在一起了。所以为了消除这种紧密耦合，我们可以使用arguments.callee。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论引用函数时使用什么名字，都可以保证正常完成递归调用。举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(trueFactorial(<span class="number">5</span>));      <span class="comment">//120</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));          <span class="comment">//0</span></span><br></pre></td></tr></table></figure></p>
<p>变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后我们又把一个返回0的函数赋值给factorial变量。如果像原来的factorial()不使用arguments.callee，那么调用trueFactorial()就会返回0。但是，在解除了耦合之后，trueFactorial()依然能够正常的计算阶乘。而再次被赋值的factorial()，只能按照重新赋给的值进行计算。</p>
<p>严格模式下，不能通过脚本访问arguments.callee，可以使用命名函数表达式来达成相同的结果，栗如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f依然有效。这种方式在严格模式和非严格模式下都行得通。</p>
<p><strong>二、this</strong></p>
<p>this引用的是函数执行的环境对象，当在网页的全局作用域中调用函数时，this对象引用的就是window。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();      <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();    <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>
<p>函数sayColor()在全局作用域中定义，并且引用了this对象。在这个函数调用之前，this的值并不确定，<strong>所以this可能在代码执行过程中引用不同的对象</strong>。</p>
<p>当在全局作用域调用sayColor()，那么this引用的是全局对象window，换句话说就是，对this.color求值会转换成对window.color求值，所以结果就是“red”。</p>
<p>当把这个函数赋值给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，所以结果就是“blue”。</p>
<p><strong>注：函数的名字仅仅是一个包含指针的变量，所以在不同的环境下执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</strong></p>
<p><strong>三、caller</strong></p>
<p>函数的caller属性保存着调用当前函数的函数的引用，<strong>如果是在全局作用域中调用当前函数，它的值是null</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(inner.caller);<span class="comment">//outer()&#123;inner();&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">outer(); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(inner.caller);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br><span class="line">inner();</span><br></pre></td></tr></table></figure></p>
<p><strong>注： 在严格模式下，访问这个属性会抛出TypeError错误</strong></p>
<h4 id="9-函数重载"><a href="#9-函数重载" class="headerlink" title="9. 函数重载"></a>9. 函数重载</h4><p>js 没有函数重载，<strong>同名即会覆盖，即便参数不同</strong>！！</p>
<h4 id="10-参数类型"><a href="#10-参数类型" class="headerlink" title="10. 参数类型"></a>10. 参数类型</h4><p> javascript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制到函数内部的参数，就和把值从一个变量复制到另一个变量一样。<strong>但是，对于基本类型和引用类型是有区别的</strong></p>
<h5 id="10-1-基本类型"><a href="#10-1-基本类型" class="headerlink" title="10.1. 基本类型"></a>10.1. 基本类型</h5><p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(命名参数或arguments对象的一个元素)，参数值的改变  <strong>不会 </strong> 反映在函数外部。</p>
<h5 id="10-1-引用类型"><a href="#10-1-引用类型" class="headerlink" title="10.1. 引用类型"></a>10.1. 引用类型</h5><p>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化 <strong>会 </strong> 反映在函数的外部<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name = <span class="string">'test'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//'test'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注：当在函数内部重写引用类型的形参时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁（<em>如果按照类似c++的按引用传递参数&amp;obj，当在函数中这个地址被指向另一个对象后，函数外的原参数也会改变</em>）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name = <span class="string">'test'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//'test'</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'white'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//'test'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br></pre></td></tr></table></figure>
<h4 id="11-与或赋值小技巧"><a href="#11-与或赋值小技巧" class="headerlink" title="11. 与或赋值小技巧"></a>11. 与或赋值小技巧</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a =  obj || <span class="string">" "</span>  ;   <span class="comment">//如果 obj 为空，a就赋值为 " " ；</span></span><br><span class="line"><span class="keyword">var</span>  a = check() &amp;&amp;  <span class="keyword">do</span>(); <span class="comment">//如果check()返回为真，就执行do()并将结果赋值给 a;</span></span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-11-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/js/" title="js">js </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://blog.nocis.ink/2018/11/21/js规范-1.变量的声明与定义/,Jared Young's Workshop,js规范-1.变量的声明与定义,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/11/21/express1-app-js/" title="express框架-1">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/11/21/js组件1-获取当前函数参数对象/" title="js组件1-获取当前函数参数对象">next post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/js/mathjax.js"></script></body></html>